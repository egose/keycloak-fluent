name: 20.Create Release Tag

on:
  workflow_dispatch:
    inputs:
      tag:
        type: string
        description: Tag Version (e.g. 1.2.3). Leave empty to auto-determine based on conventional commits.
        required: false
        default: ''

jobs:
  tag-changelog:
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: Fail on tags (Workflow must run on a branch)
        run: |
          echo "Current Ref: ${{ github.ref }}"
          if [[ ! "${{ github.ref }}" =~ ^refs/heads/ ]]; then
            echo "::error::This workflow must be run on a branch, not a tag."
            exit 1
          fi

      - name: Checkout Repository
        uses: actions/checkout@b4ffde65f46336ab88eb5aea80decbc599b8232a # v4.1.1
        with:
          ssh-key: ${{ secrets.SSH_KEY }}
          fetch-depth: 0
          fetch-tags: true

      - name: Determine Next Tag Version
        id: new-tag
        run: |
          NEXT_VERSION=""
          INPUT_TAG="${{ github.event.inputs.tag }}"

          if [ -n "$INPUT_TAG" ]; then
            # 1. Manually provided tag validation
            if ! echo "$INPUT_TAG" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              echo "::error::Provided tag '$INPUT_TAG' does not follow semantic versioning (major.minor.patch)"
              exit 1
            fi
            NEXT_VERSION="${INPUT_TAG//v}" # Remove 'v' prefix if present
            echo "Tag specified manually: $NEXT_VERSION"
          else
            # 2. Auto-determination using Conventional Commits
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

            if [ -z "$LAST_TAG" ]; then
              echo "::error::No previous tag found and no tag input provided. Cannot auto-determine."
              exit 1
            fi

            # Use `npm version` or `release-it` dry-run logic for better maintainability.
            # Keeping the existing bash logic but improving error reporting.
            if ! [[ $LAST_TAG =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
               echo "::error::Last tag '$LAST_TAG' does not follow expected 'vX.Y.Z' format."
               exit 1
            fi

            # Use git log --format to get commit messages for bumping (more efficient than two greps)
            COMMIT_MESSAGES=$(git log ${LAST_TAG}..HEAD --pretty=format:%B)

            # Placeholder for retained BASH logic output
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"

            if echo "$COMMIT_MESSAGES" | grep -qE '(BREAKING CHANGE:|^feat\([^\)]+\)!:|^fix\([^\)]+\)!:|!:)'; then
                BUMP="major"
            elif echo "$COMMIT_MESSAGES" | grep -qE '^feat(\(.+\))?:'; then
                BUMP="minor"
            else
                BUMP="patch"
            fi

            case "$BUMP" in
              major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
              minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
              patch) PATCH=$((PATCH + 1)) ;;
            esac

            NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            echo "Determined next version: ${NEXT_VERSION} (Based on $BUMP bump)"
          fi

          # Set output variable
          echo "tag=$NEXT_VERSION" >> "$GITHUB_OUTPUT"

      - name: Setup Tools
        uses: ./.github/actions/setup-tools

      - name: Setup NPM Packages
        uses: ./.github/actions/setup-npm

      - name: Create Tag and Changelog with release-it
        id: release-it
        run: |
          TAG_VERSION="v${{ steps.new-tag.outputs.tag }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # 1. Create temporary branch for changelog commit
          branch="changelog/${{ steps.new-tag.outputs.tag }}"
          BASE_BRANCH="${{ github.ref_name }}"

          # Clean up local/remote branch
          git push origin --delete "$branch" || true
          git branch -D "$branch" || true

          git checkout -b "$branch"
          git push --set-upstream origin "$branch"

          # 2. Run release-it: creates tag and updates changelog file
          # Pass the computed version WITHOUT a leading 'v'.
          # Release-it will prepend 'v' itself, producing 'vX.Y.Z'.
          ./node_modules/.bin/release-it ${{ steps.new-tag.outputs.tag }} --ci

          # 3. Get the tag message/body for the PR
          # This is the most reliable way to get the content generated by release-it
          # Use `jq` to create a JSON-safe string for the PR body
          TAG_BODY=$(git tag -l --format='%(contents)' "$TAG_VERSION")

          echo "pr_title=chore(release): release candidate $TAG_VERSION" >> "$GITHUB_OUTPUT"
          echo "pr_body<<EOF_BODY" >> "$GITHUB_OUTPUT"
          echo "$TAG_BODY" >> "$GITHUB_OUTPUT"
          echo "EOF_BODY" >> "$GITHUB_OUTPUT"
          echo "head_branch=$branch" >> "$GITHUB_OUTPUT"
          echo "base_branch=$BASE_BRANCH" >> "$GITHUB_OUTPUT"
          echo "version=$TAG_VERSION" >> "$GITHUB_OUTPUT

      - name: Create Pull Request
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { pr_title, pr_body, head_branch, base_branch, version } = steps['release-it'].outputs;
            const { repo, owner } = context.repo;

            console.log(`Creating PR for ${version} from ${head_branch} to ${base_branch}`);

            const pr = await github.rest.pulls.create({
              owner,
              repo,
              head: head_branch,
              base: base_branch,
              title: pr_title,
              body: `### Release Candidate Details

            ${pr_body}

            ---

            > ℹ️ **This PR was automatically generated.** Once merged, the tag **${version}** will be finalized and the release published.`,
            });

            console.log(`Created PR: ${pr.data.html_url}`);

            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: pr.data.number,
              labels: ['changelog', 'release-candidate', version]
            });
